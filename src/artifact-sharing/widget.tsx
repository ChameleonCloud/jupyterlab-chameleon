import { Button, ControlGroup, FormGroup, HTMLSelect, InputGroup, IconName, TextArea } from '@blueprintjs/core';
import { ReactWidget } from '@jupyterlab/apputils';
import { Intent } from '@jupyterlab/ui-components';
import * as React from 'react';
import { ChangeEvent } from 'react';
import {
  Artifact,
  ArtifactAuthor,
  ArtifactLink,
  ArtifactProject,
  ArtifactVisibility,
  IArtifactRegistry,
  IArtifactSharingURL,
  Workflow
} from './tokens';

enum WidgetState {
  CONFIRM_FORM = 'confirm-form',
  ARTIFACT_FORM = 'artifact-form',
  WAITING = 'waiting',
  SUCCESS = 'success'
}

namespace ArtifactSharingComponent {
  export interface IProps {
    initialArtifact: Artifact;
    workflow: Workflow;
    urlFactory: IArtifactSharingURL;
    artifactRegistry: IArtifactRegistry;
    onCancel(): void;
  }

  export interface IState {
    currentState: WidgetState;
    errorMessage?: string;
    waitMessage?: string;
    artifact?: Artifact;
  }

  export interface IFormResultPayload {
    message: 'save_result' | any;
    body: {
      status: 'success' | 'cancel';
      id?: string;
    };
  }
}

namespace ArtifactText {
  export interface IProps {
    urlFactory: IArtifactSharingURL;
    artifact?: Artifact;
  }
}

namespace ArtifactForm {

  export interface IProps {
    artifact: Artifact;
    workflow: Workflow;
    formVisibility: object;
    formText: React.ElementRef<any>;
    onChange: (fieldName: string) => (event: ChangeEvent<HTMLInputElement | HTMLTextAreaElement | HTMLSelectElement>) => void;
    onListChange: <T>(fieldName: string) => (list: Array<T>) => void
    onSubmit: (event: React.FormEvent) => Promise<void>;
    error: string;
  }

  export interface ListProps<E extends JSX.Element, T> {
    label?: string;
    labelInfo?: string;
    helperText?: string;
    // When a new item is added to the list, it will be generated by this function
    newComponentGenerator: (item: T, updater: (field: string) => (event: ChangeEvent<HTMLInputElement>) => void, deleter: () => void) => E;
    newObjectGenerator: () => T;
    list: Array<T>;
    artifactUpdater: (items: Array<T>) => void;
  }

  export interface AuthorProps {
    author: ArtifactAuthor;
    onFieldChange: (field: string) => (event: ChangeEvent<HTMLInputElement>) => void;
    onDelete: () => void;
  }

  export interface ProjectProps {
    project: ArtifactProject;
    onFieldChange: (field: string) => (event: ChangeEvent<HTMLInputElement>) => void;
  }

  export interface LinkProps {
    link: ArtifactLink;
    onFieldChange: (field: string) => (event: ChangeEvent<HTMLInputElement>) => void;
  }
}

class NewArtifactText extends React.Component<ArtifactText.IProps> {
  render() {
    return (
      <div className='chi-ArtifactForm-text'>
        <h2>Package new artifact</h2>
        <p>
          Packaging your work as an <i>artifact</i> makes it easier to share
          your Notebook(s) and related files with others. A packaged experiment:
        </p>
        <ul>
          <li>can by &ldquo;replayed&rdquo; by any Chameleon user</li>
          <li>
            is displayed in{' '}
            <a
              href={this.props.urlFactory.indexUrl()}
              rel="noreferrer"
              target="_blank"
            >
              Chameleon Trovi
            </a>{' '}
            (artifact sharing system)
          </li>
          <li>
            is initially private to you, but can be shared, either with specific
            projects, or all users
          </li>
          <li>supports versioning, if you ever want to make changes</li>
        </ul>
        <p>
          To learn more about Trovi, and artifact packaging, please refer to the{' '}
          <a
            href="https://chameleoncloud.readthedocs.io"
            rel="noreferrer"
            target="_blank"
          >
            Chameleon documentation
          </a>
          .
        </p>
      </div>
    );
  }
}

class NewArtifactSuccessText extends React.Component<ArtifactText.IProps> {
  render() {
    return (
      <div className='chi-ArtifactForm-text'>
        <h2>Your artifact was successfully packaged.</h2>
        {this.props.artifact && (
          <p>
            You can view your artifact at any time on{' '}
            <a
              href={this.props.urlFactory.detailUrl(this.props.artifact.uuid)}
              target="_blank"
              rel="noreferrer"
            >
              Trovi
            </a>
            .
          </p>
        )}
        <p>You may now close this window.</p>
      </div>
    );
  }
}

class NewArtifactVersionText extends React.Component<ArtifactText.IProps> {
  render() {
    return (
      <div className='chi-ArtifactForm-text'>
        <h2>Create new artifact version</h2>
        <p>
          When you create a new version of an existing package, your
          package&rsquo;s files are re-uploaded and then saved as a new
          launchable artifact. Creating a new version makes sense if you make
          adjustments to your code or Notebooks, perhaps fixing a bug or adding
          additional capabilities or functionality.
        </p>
        <p>
          If you want to start a new packaged artifact, you can do so by moving
          the files you want included in the package to their own directory,
          outside of any already-published package directories.
        </p>
        <p>
          All package versions are displayed in Trovi along with your existing
          artifact title, description, and other metadata. You can optionally
          edit this metadata before saving your new version.
        </p>
      </div>
    );
  }
}

class EditArtifactText extends React.Component<ArtifactText.IProps> {
  render() {
    return (
      <div className='chi-ArtifactForm-text'>
        <h2>Edit artifact</h2>
      </div>
    )
  }
}

class EditArtifactSuccessText extends React.Component<ArtifactText.IProps> {
  render() {
    return (
      <div className='chi-ArtifactForm-text'>
        <h2>Your artifact has been updated.</h2>
        <p>You may now close this window.</p>
      </div>
    );
  }
}

class NewArtifactVersionSuccessText extends React.Component<ArtifactText.IProps> {
  render() {
    return (
      <div>
        <h2>A new version of your artifact was created.</h2>
        {this.props.artifact && (
          <p>
            You can view your artifact at any time on{' '}
            <a
              href={this.props.urlFactory.detailUrl(this.props.artifact.uuid)}
              target="_blank"
              rel="noreferrer"
            >
              Trovi
            </a>
            .
          </p>
        )}
        <p>You may now close this window.</p>
      </div>
    );
  }
}

class ArtifactDynamicLengthList<E extends JSX.Element, T> extends React.Component<ArtifactForm.ListProps<E, T>> {
  static defaultProps: { disabled: false };

  constructor(props: ArtifactForm.ListProps<E, T>) {
    super(props);
    const initialList = this.props.list;
    this.state = { list: initialList.length > 0 ? initialList : [this.props.newObjectGenerator()] };
  }

  addItem() {
    return () => {
      let copy = [...this.props.list, this.props.newObjectGenerator()];
      return this.props.artifactUpdater(copy);
    };
  }

  removeItem(index: number) {
    return () => {
      let copy = [...this.props.list];
      copy.splice(index, 1);
      return this.props.artifactUpdater(copy);
    }
  }

  updateItem(index: number) {
    return (field: string) => {
      return (event: ChangeEvent<HTMLInputElement>) => {
        const value = event.target.value;
        let newList = [...this.props.list]
        newList[index] = { ...newList[index], [field]: value }
        return this.props.artifactUpdater(newList);
      };
    };
  }

  getListForComponents(): Array<T> {
    if (this.props.list.length < 1) {
      return [this.props.newObjectGenerator()];
    } else {
      return this.props.list;
    }
  }

  render() {
    return (
      <FormGroup className='chi-ListComponent'
        label={this.props.label}
        labelInfo={this.props.labelInfo}
        helperText={this.props.helperText}>
        {this.getListForComponents().map((item, index) => (
          <div className='chi-ListComponent-Item' key={index}>
            {this.props.newComponentGenerator(item, this.updateItem(index), this.removeItem(index))}
          </div>
        )
        )}
        <Button small={true} onClick={this.addItem()} icon='plus'>Add author</Button>
      </FormGroup>
    )
  }
}

class ArtifactAuthorComponent extends React.Component<ArtifactForm.AuthorProps> {
  constructor(props: ArtifactForm.AuthorProps) {
    super(props);
  }

  hasAnyInput(): boolean {
    const author = this.props.author;
    return author.email !== "" || author.affiliation !== "" || author.full_name !== "";
  }

  render(): JSX.Element {
    const author = this.props.author;
    const onDelete = () => this.props.onDelete();
    return (
      <ControlGroup fill={true}>
        <InputGroup
          placeholder='Full name'
          required={this.hasAnyInput()}
          value={author.full_name}
          onChange={this.props.onFieldChange('full_name')} />
        <InputGroup
          placeholder='Email address'
          required={this.hasAnyInput()}
          value={author.email}
          onChange={this.props.onFieldChange('email')} />
        <InputGroup
          placeholder='Affiliation'
          required={this.hasAnyInput()}
          value={author.affiliation}
          onChange={this.props.onFieldChange('affiliation')} />
        <Button icon='trash' small={true} onClick={onDelete}>Delete</Button>
      </ControlGroup>
      // <div className="authorInput">
      //   <label>
      //     <p>Full Name</p>
      //     <input
      //       name="author_full_name"
      //       type="text"
      //       className={Classes.INPUT}
      //       placeholder="The author's full name"
      //       required={this.hasAnyInput()}
      //       value={author.full_name}
      //       onChange={this.props.onFieldChange("full_name")}
      //       disabled={this.props.disabled}
      //     />
      //   </label>
      //   <label>
      //     <p>E-Mail Address</p>
      //     <input
      //       name="author_email"
      //       type="email"
      //       className={Classes.INPUT}
      //       placeholder="The author's e-mail address"
      //       required={this.hasAnyInput()}
      //       value={author.email}
      //       onChange={this.props.onFieldChange("email")}
      //       disabled={this.props.disabled}
      //     />
      //   </label>
      //   <label>
      //     <p>Affiliation</p>
      //     <input
      //       name="author_affiliation"
      //       type="text"
      //       className={Classes.INPUT}
      //       placeholder="The organization or group with which the author is affiliated"
      //       value={author.affiliation}
      //       onChange={this.props.onFieldChange("affiliation")}
      //       disabled={this.props.disabled}
      //     />
      //   </label>
      // </div>
    )
  }
}

// class ArtifactLinkedProjectComponent extends React.Component<ArtifactForm.ProjectProps> {
//   constructor(props: ArtifactForm.ProjectProps) {
//     super(props);
//   }

//   render() {
//     const project = this.props.project;
//     return (
//       <div className="linkedProjectInput">
//         <label>
//           <p>URN</p>
//           {/* We just let users input a raw URN. We should probably have a dropdown of their projects... */}
//           <input
//             name="linked-Project-Urn-Input"
//             type="text"
//             placeholder="A URN describing a project"
//             onChange={this.props.onFieldChange("urn")}
//             value={project.urn}
//             disabled={this.props.disabled}
//           />
//         </label>
//       </div>
//     )
//   }
// }

// class ArtifactLinkComponent extends React.Component<ArtifactForm.LinkProps> {
//   constructor(props: ArtifactForm.LinkProps) {
//     super(props);
//   }

//   isAnythingSet(): boolean {
//     const link = this.props.link;
//     return (link.urn !== null &&
//       link.urn !== undefined &&
//       link.urn !== "") ||
//       (link.label !== null &&
//         link.label !== undefined &&
//         link.label !== "");
//   }

//   render() {
//     const link = this.props.link;
//     return (
//       <div className="linkInput">
//         <label>
//           <p>URN</p>
//           {/* This should be reworked, rather than just allowing the user to set arbitrary URNs */}
//           <input name="link_urn" type="text" placeholder="A URN string describing the link"
//             required={this.isAnythingSet()}
//             value={link.urn}
//             onChange={this.props.onFieldChange("urn")} />
//         </label>
//         <label>
//           <p>Label</p>
//           <input name="link_label" type="text" placeholder="A label which describes the link's content"
//             required={this.isAnythingSet()}
//             value={link.label}
//             onChange={this.props.onFieldChange("label")} />
//         </label>
//       </div>
//     )
//   }
// }

class ArtifactEditForm extends React.Component<ArtifactForm.IProps> {
  static readonly hidden = { display: 'none' };
  static readonly block = { display: 'block' };

  isUploadForm(): boolean {
    return this.props.workflow === 'upload';
  }

  isNewVersionForm(): boolean {
    return !!this.props.artifact.uuid && this.isUploadForm();
  }

  render(): JSX.Element {
    // Construct a list of form fields to add to the form.
    // NOTE: whenever this is updated, ensure the list of allowed update keys is
    // also updated if you want to allow editing the field later via this interface.
    // (See ArtifactRegistry.updateArtifact).
    const fields: JSX.Element[] = [];
    let submitText: JSX.Element;
    let submitIcon: IconName;

    if (this.isUploadForm()) {
      submitText = <span>Upload: <code>{this.props.artifact.path}/</code></span>
      submitIcon = 'upload'
    } else {
      submitText = <span>Save</span>
      submitIcon = 'floppy-disk'
    }

    if (!this.isNewVersionForm()) {
      fields.push(
        <FormGroup
          label="Title"
          labelFor="chi-ArtifactForm-title"
          labelInfo="(required)">
          <InputGroup
            id="chi-ArtifactForm-title"
            required={true}
            placeholder="The title of your experiment"
            value={this.props.artifact.title}
            onChange={this.props.onChange("title")} />
        </FormGroup>
      );
      fields.push(
        <FormGroup
          label="Short description"
          labelFor="chi-ArtifactForm-short-description"
          labelInfo="(required)">
          <InputGroup
            id="chi-ArtifactForm-short-description"
            placeholder="A short description of your experiment"
            required={true}
            value={this.props.artifact.short_description}
            onChange={this.props.onChange('short_description')} />
        </FormGroup>
      );
      fields.push(
        <FormGroup
          label="Long description"
          labelFor="chi-ArtifactForm-long-description"
          helperText="Supports GitHub-flavored markdown"
        >
          <TextArea
            id="chi-ArtifactForm-long-description"
            fill={true}
            growVertically={true}
            style={{ minHeight: '5rem' }}
            value={this.props.artifact.long_description}
            onChange={this.props.onChange("long_description")} />
        </FormGroup>
      );
      fields.push(
        <FormGroup
          label='Visibility'
          helperText='Public artifacts are visible to any user, private artifacts are visible only to you and those you have shared it with.'
          labelFor='chi-ArtifactForm-visibility'>
          <HTMLSelect
            id='chi-ArtifactForm-visibility'
            title='Allow other users to view your artifact'
            defaultValue={this.props.artifact.visibility}
            onChange={this.props.onChange('visibility')}
          >
            <option value={ArtifactVisibility.PRIVATE}>private</option>
            <option value={ArtifactVisibility.PUBLIC}>public</option>
          </HTMLSelect>
        </FormGroup>
      );
      fields.push(
        <ArtifactDynamicLengthList
          label='Authors'
          helperText={
            'List any individuals you would like to credit. This is purely for display purposes and does not control who is able to edit the artifact.'}
          artifactUpdater={this.props.onListChange("authors")}
          newComponentGenerator={(item, onFieldChange, onDelete) =>
            <ArtifactAuthorComponent author={item} onFieldChange={onFieldChange} onDelete={onDelete} />
          }
          newObjectGenerator={() => ({ full_name: "", email: "", affiliation: "" })}
          list={[...this.props.artifact.authors]}
        />
      )
    }

    return (
      <form onSubmit={this.props.onSubmit} style={this.props.formVisibility}>
        {this.props.error && (
          <div className="chi-ArtifactSharing-ErrorMessage">
            {this.props.error}
          </div>
        )}
        {this.props.formText}
        {fields}
        <div className="chi-ArtifactSharing-FormActions">
          <Button type='submit' icon={submitIcon} large={true} intent={Intent.PRIMARY}>
            {submitText}
          </Button>
        </div>
      </form>
    )
  }
}

export class ArtifactSharingComponent extends React.Component<ArtifactSharingComponent.IProps, ArtifactSharingComponent.IState> {
  constructor(props: ArtifactSharingComponent.IProps) {
    super(props);

    this.state = {
      artifact: this.props.initialArtifact,
      currentState: WidgetState.ARTIFACT_FORM,
      errorMessage: null,
      waitMessage: null
    };

    this.onSubmit = this.onSubmit.bind(this);
    this.handleChange = this.handleChange.bind(this);
    this.handleListChange = this.handleListChange.bind(this);
  }

  handleChange(fieldName: string) {
    return (event: ChangeEvent<HTMLInputElement | HTMLTextAreaElement | HTMLSelectElement>) => {
      switch (fieldName) {
        case "visibility":
          this.setState({
            artifact: {
              ...this.state.artifact,
              visibility: event.target.value as ArtifactVisibility
            }
          });
          return;
        case "enable_requests":
          this.setState({
            artifact: {
              ...this.state.artifact,
              reproducibility: {
                ...this.state.artifact.reproducibility,
                enable_requests: (event.target as HTMLInputElement).checked
              }
            }
          });
          return;
        case "access_hours":
          this.setState({
            artifact: {
              ...this.state.artifact,
              reproducibility: {
                ...this.state.artifact.reproducibility,
                access_hours: event.target.value as unknown as number
              }
            }
          });
          return;
        default:
          this.setState({ artifact: { ...this.state.artifact, [fieldName]: event.target.value } });
          return;
      }
    };
  }

  handleListChange<T>(fieldName: string) {
    return (list: Array<T>) => {
      this.setState({ artifact: { ...this.state.artifact, [fieldName]: list } });
    }
  }

  async onSubmit(event: React.FormEvent): Promise<void> {
    event.preventDefault();

    const successState: ArtifactSharingComponent.IState = {
      currentState: WidgetState.SUCCESS,
      errorMessage: null,
    }

    if (this.props.workflow === 'upload') {
      this.setState({
        currentState: WidgetState.WAITING,
        waitMessage: 'Please wait while your artifact files are uploaded'
      });

      try {
        if (this.state.artifact.uuid) {
          await this.props.artifactRegistry.newArtifactVersion(this.state.artifact);
        } else {
          successState.artifact = await this.props.artifactRegistry.createArtifact(this.state.artifact);
        }
        this.setState(successState);
      } catch (e) {
        this.setState({
          currentState: WidgetState.ARTIFACT_FORM,
          errorMessage: `Failed to package artifact: ${e.message}`
        });
      }
    } else if (this.props.workflow === 'edit') {
      this.setState({
        currentState: WidgetState.WAITING,
        waitMessage: 'Saving artifact'
      });

      try {
        await this.props.artifactRegistry.updateArtifact(this.state.artifact);
        this.setState(successState);
      } catch (e) {
        this.setState({
          currentState: WidgetState.ARTIFACT_FORM,
          errorMessage: `Failed to save artifact: ${e.message}`
        });
      }
    }
  }

  render(): JSX.Element {
    const hidden = { display: 'none' };
    const block = { display: 'block' };
    const visibilities = this._allStates.reduce((memo, state: WidgetState) => {
      memo[state] = this.state.currentState === state ? block : hidden;
      return memo;
    }, {} as { [key in WidgetState]: { display: string } });

    let formText: React.ElementRef<any>;
    let successText: React.ElementRef<any>;

    // Check if we started from an already-published artifact.
    if (this.props.workflow === 'upload') {
      if (this.props.initialArtifact.uuid) {
        formText = <NewArtifactVersionText urlFactory={this.props.urlFactory} />;
        successText = (
          <NewArtifactVersionSuccessText
            urlFactory={this.props.urlFactory}
            artifact={this.state.artifact}
          />
        );
      } else {
        formText = <NewArtifactText urlFactory={this.props.urlFactory} />;
        successText = (
          <NewArtifactSuccessText
            urlFactory={this.props.urlFactory}
            artifact={this.state.artifact}
          />
        );
      }
    } else {
      formText = <EditArtifactText urlFactory={this.props.urlFactory} />;
      successText = (
        <EditArtifactSuccessText urlFactory={this.props.urlFactory} artifact={this.state.artifact} />
      );
    }

    return (
      <div className="chi-Expand">
        <div
          className="chi-ArtifactSharing-Form"
          style={visibilities[WidgetState.ARTIFACT_FORM]}
        >
          {this.state.currentState === WidgetState.ARTIFACT_FORM && (
            <ArtifactEditForm
              artifact={this.state.artifact}
              workflow={this.props.workflow}
              formVisibility={visibilities[WidgetState.ARTIFACT_FORM]}
              formText={formText}
              onChange={this.handleChange}
              onListChange={this.handleListChange}
              onSubmit={this.onSubmit}
              error={this.state.errorMessage}
            />
          )
          }
        </div>
        <div
          className="chi-ArtifactSharing-Form"
          style={visibilities[WidgetState.WAITING]}
        >
          <div className="jp-Spinner">
            <div className="jp-SpinnerContent"></div>
            <div className="chi-ArtifactSharing-LoadingMessage">
              {this.state.waitMessage}
            </div>
          </div>
        </div>
        <div
          className="chi-ArtifactSharing-Form"
          style={visibilities[WidgetState.SUCCESS]}
        >
          {this.state.errorMessage && (
            <div className="chi-ArtifactSharing-ErrorMessage">
              {this.state.errorMessage}
            </div>
          )}
          {successText}
        </div>
      </div>
    );
  }

  private _allStates = Object.values(WidgetState);
}

export class ArtifactSharingWidget extends ReactWidget {
  constructor(
    artifact: Artifact,
    workflow: Workflow,
    urlFactory: IArtifactSharingURL,
    artifactRegistry: IArtifactRegistry
  ) {
    super();
    this.id = 'artifact-sharing-Widget';
    this._artifact = artifact;
    this._workflow = workflow;
    this._urlFactory = urlFactory;
    this._artifactRegistry = artifactRegistry;
  }

  render(): JSX.Element {
    return (
      <ArtifactSharingComponent
        initialArtifact={this._artifact}
        workflow={this._workflow}
        urlFactory={this._urlFactory}
        artifactRegistry={this._artifactRegistry}
        // Disposing of a widget added to a MainContentArea will cause the
        // content area to also dispose of itself (close itself.)
        onCancel={this.dispose.bind(this)}
      />
    );
  }

  private _artifact: Artifact;
  private _workflow: Workflow;
  private _urlFactory: IArtifactSharingURL;
  private _artifactRegistry: IArtifactRegistry;
}
