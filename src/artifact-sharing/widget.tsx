import {ReactWidget} from '@jupyterlab/apputils';
import * as React from 'react';
import {ChangeEvent} from 'react';
import {
  Artifact,
  ArtifactAuthor,
  ArtifactLink,
  ArtifactProject,
  ArtifactVisibility,
  IArtifactRegistry,
  IArtifactSharingURL,
  Workflow
} from './tokens';

enum WidgetState {
  CONFIRM_FORM = 'confirm-form',
  ARTIFACT_FORM = 'artifact-form',
  WAITING = 'waiting',
  SUCCESS = 'success'
}

namespace ArtifactSharingComponent {
  export interface IProps {
    initialArtifact: Artifact;
    workflow: Workflow;
    urlFactory: IArtifactSharingURL;
    artifactRegistry: IArtifactRegistry;
    onCancel(): void;
  }

  export interface IState {
    currentState: WidgetState;
    errorMessage?: string;
    artifact?: Artifact;
  }

  export interface IFormResultPayload {
    message: 'save_result' | any;
    body: {
      status: 'success' | 'cancel';
      id?: string;
    };
  }
}

namespace ArtifactText {
  export interface IProps {
    urlFactory: IArtifactSharingURL;
    artifact?: Artifact;
  }
}

namespace ArtifactForm {

  export interface IProps {
    initialArtifact: Artifact;
    formVisibility: object;
    sharingComponent: ArtifactSharingComponent;
  }

  export interface IState {
    artifact: Artifact;
  }

  export interface ListProps<E extends JSX.Element, T> {
    // When a new item is added to the list, it will be generated by this function
    newComponentGenerator: (item: T, updater: (field: string) => (event: ChangeEvent<HTMLInputElement>) => void, getter: () => T) => E;
    newObjectGenerator: () => T;
    initialList: Array<T>;
    artifactUpdater: (items: Array<T>) => void;
  }

  export interface ListState<T> {
    list: Array<T>;
  }

  export interface AuthorProps {
    initialAuthor: ArtifactAuthor;
    onFieldChange: (field: string) => (event: ChangeEvent<HTMLInputElement>) => void;
    getAuthor: () => ArtifactAuthor;
  }

  export interface ProjectProps {
    initialProject: ArtifactProject;
    onFieldChange: (field: string) => (event: ChangeEvent<HTMLInputElement>) => void;
    getProject: () => ArtifactProject;
  }

  export interface LinkProps {
    initialLink: ArtifactLink;
    onFieldChange: (field: string) => (event: ChangeEvent<HTMLInputElement>) => void;
    getLink: () => ArtifactLink;
  }
}

class NewArtifactText extends React.Component<ArtifactText.IProps> {
  render() {
    return (
        <div>
          <h2>Package new artifact</h2>
          <p>
            Packaging your work as an <i>artifact</i> makes it easier to share
            your Notebook(s) and related files with others. A packaged experiment:
          </p>
          <ul>
            <li>can by &ldquo;replayed&rdquo; by any Chameleon user</li>
            <li>
              is displayed in{' '}
              <a
                  href={this.props.urlFactory.indexUrl()}
                  rel="noreferrer"
                  target="_blank"
              >
                Chameleon Trovi
              </a>{' '}
              (artifact sharing system)
            </li>
            <li>
              is initially private to you, but can be shared, either with specific
              projects, or all users
            </li>
            <li>supports versioning, if you ever want to make changes</li>
          </ul>
          <p>
            To learn more about Trovi, and artifact packaging, please refer to the{' '}
            <a
                href="https://chameleoncloud.readthedocs.io"
                rel="noreferrer"
                target="_blank"
            >
              Chameleon documentation
            </a>
            .
          </p>
        </div>
    );
  }
}

class NewArtifactSuccessText extends React.Component<ArtifactText.IProps> {
  render() {
    return (
      <div>
        <h2>Your artifact was successfully packaged.</h2>
        {this.props.artifact && (
          <p>
            You can view your artifact at any time on{' '}
            <a
              href={this.props.urlFactory.detailUrl(this.props.artifact.id)}
              target="_blank"
              rel="noreferrer"
            >
              Trovi
            </a>
            .
          </p>
        )}
        <p>You may now close this window.</p>
      </div>
    );
  }
}

class NewArtifactVersionText extends React.Component<ArtifactText.IProps> {
  render() {
    return (
      <div>
        <h2>Create new artifact version</h2>
        <p>
          When you create a new version of an existing package, your
          package&rsquo;s files are re-uploaded and then saved as a new
          launchable artifact. Creating a new version makes sense if you make
          adjustments to your code or Notebooks, perhaps fixing a bug or adding
          additional capabilities or functionality.
        </p>
        <p>
          If you want to start a new packaged artifact, you can do so by moving
          the files you want included in the package to their own directory,
          outside of any already-published package directories.
        </p>
        <p>
          All package versions are displayed in Trovi along with your existing
          artifact title, description, and other metadata. You can optionally
          edit this metadata before saving your new version.
        </p>
      </div>
    );
  }
}

class NewArtifactVersionSuccessText extends React.Component<ArtifactText.IProps> {
  render() {
    return (
      <div>
        <h2>A new version of your artifact was created.</h2>
        {this.props.artifact && (
          <p>
            You can view your artifact at any time on{' '}
            <a
              href={this.props.urlFactory.detailUrl(this.props.artifact.id)}
              target="_blank"
              rel="noreferrer"
            >
              Trovi
            </a>
            .
          </p>
        )}
        <p>You may now close this window.</p>
      </div>
    );
  }
}

class ArtifactDynamicLengthList<E extends JSX.Element, T> extends React.Component<ArtifactForm.ListProps<E, T>, ArtifactForm.ListState<T>> {
  constructor(props: ArtifactForm.ListProps<E, T>) {
    super(props);

    const initialList = this.props.initialList;
    this.state = {list: initialList.length > 0 ? initialList : [this.props.newObjectGenerator()]};
  }

  addItem(index: number) {
    return (_: any) => {
      let copy = [...this.state.list];
      copy.splice(index + 1, 0, this.props.newObjectGenerator());
      this.setState({
        list: copy
      });
    };
  }

  removeItem(index: number) {
    return (_: any) => {
      let copy = [...this.state.list];
      copy.splice(index, 1);
      this.setState({
        list: copy
      });
    }
  }

  updateItem(index: number) {
    return (field: string) => {
      return (event: ChangeEvent<HTMLInputElement>) => {
        const value = event.target.value;
        let newList = [...this.state.list]
        newList[index] = {...newList[index], [field]: value}
        this.setState({
          list: newList
        });
      };
    };
  }

  getItem(index: number) {
    alert(`${index}: ${JSON.stringify(this.state.list[index])}`);
    return () => this.state.list[index];
  }

  render() {
    return (
        <ul>
          {this.state.list.map((item, index) => (
                  <div key={index}>
                    <li>{this.props.newComponentGenerator(item, this.updateItem(index), this.getItem(index))}</li>
                    <button type="button" onClick={this.addItem(index)}>+</button>
                    <button type="button" onClick={this.removeItem(index)}>-</button>
                  </div>
              )
          )}
        </ul>
    )
  }
}

class ArtifactAuthorComponent extends React.Component<ArtifactForm.AuthorProps> {
  constructor(props: ArtifactForm.AuthorProps) {
    super(props);
  }

  hasAnyInput(): boolean {
    const author = this.props.getAuthor();
    return author.email !== "" || author.affiliation !== "" || author.full_name !== "";
  }

  render(): JSX.Element {
    const author = this.props.getAuthor();
    return (
        <div className="authorInput">
          <label>
            <p>Full Name</p>
            <input name="author_full_name" type="text" placeholder="The author's full name"
                   required={this.hasAnyInput()}
                   value={author.full_name}
                   onChange={this.props.onFieldChange("full_name")}/>
          </label>
          <label>
            <p>E-Mail Address</p>
            <input name="author_email" type="email" placeholder="The author's e-mail address"
                   required={this.hasAnyInput()}
                   value={author.email}
                   onChange={this.props.onFieldChange("email")}/>
          </label>
          <label>
            <p>Affiliation</p>
            <input name="author_affiliation" type="text"
                   placeholder="The organization or group with which the author is affiliated"
                   value={author.affiliation}
                   onChange={this.props.onFieldChange("affiliation")}/>
          </label>
        </div>
    )
  }
}

class ArtifactLinkedProjectComponent extends React.Component<ArtifactForm.ProjectProps> {
  constructor(props: ArtifactForm.ProjectProps) {
    super(props);
  }

  render() {
    const project = this.props.getProject();
    return (
        <div className="linkedProjectInput">
          <label>
            <p>URN</p>
            {/* We just let users input a raw URN. We should probably have a dropdown of their projects... */}
            <input name="linked-Project-Urn-Input" type="text" placeholder="A URN describing a project"
                   onChange={this.props.onFieldChange("urn")} value={project.urn}/>
          </label>
        </div>
    )
  }
}

class ArtifactLinkComponent extends React.Component<ArtifactForm.LinkProps> {
  constructor(props: ArtifactForm.LinkProps) {
    super(props);
  }

  isAnythingSet(): boolean {
    const link = this.props.getLink();
    return (link.urn !== null &&
            link.urn !== undefined &&
            link.urn !== "") ||
        (link.label !== null &&
            link.label !== undefined &&
            link.label !== "");
  }

  render() {
    const link = this.props.getLink();
    return (
        <div className="linkInput">
          <label>
            <p>URN</p>
            {/* This should be reworked, rather than just allowing the user to set arbitrary URNs */}
            <input name="link_urn" type="text" placeholder="A URN string describing the link"
                   required={this.isAnythingSet()}
                   value={link.urn}
                   onChange={this.props.onFieldChange("urn")}/>
          </label>
          <label>
            <p>Label</p>
            <input name="link_label" type="text" placeholder="A label which describes the link's content"
                   required={this.isAnythingSet()}
                   value={link.label}
                   onChange={this.props.onFieldChange("label")}/>
          </label>
        </div>
    )
  }
}

class ArtifactEditForm extends React.Component<ArtifactForm.IProps, ArtifactForm.IState> {
  static readonly hidden = {display: 'none'};
  static readonly block = {display: 'block'};

  constructor(props: ArtifactForm.IProps) {
    super(props);

    this.state = {artifact: this.props.initialArtifact};

    this.handleChange = this.handleChange.bind(this);
  }

  handleChange(fieldName: string) {
    return (event: ChangeEvent<HTMLInputElement>) => {
      this.setState({artifact: {...this.state.artifact, [fieldName]: event.target.value}})
    };
  }

  handleReproChange(fieldName: string) {
    return (event: ChangeEvent<HTMLInputElement>) => {
      let newRepro = {...this.state.artifact.reproducibility, [fieldName]: event.target.checked};
      this.setState({artifact: {...this.state.artifact, reproducibility: newRepro}});
    }
  }

  render(): JSX.Element {
    return (
        <form onSubmit={(event: React.FormEvent) => {
          console.trace();
          this.props.sharingComponent.setState({...this.props.sharingComponent.state, artifact: this.state.artifact});
          return this.props.sharingComponent.onSubmit(event);
        }} style={this.props.formVisibility}>
          <fieldset id="artifactFormInputs">
            <label style={this.state.artifact.id ? ArtifactEditForm.block : ArtifactEditForm.hidden}>
              <p>ID</p>
              <input name="id" type="text" value={this.state.artifact.id}
                     alt="The UUID used to reference this artifact" disabled/>
            </label>
            <label>
              <p className="chi-ArtifactSharing-Form-Required">Title</p>
              <input name="title" type="text" placeholder="The title of your experiment" required={true}
                     onChange={this.handleChange("title")}/>
            </label>
            <label>
              <p className="chi-ArtifactSharing-Form-Required">Short Description</p>
              <input name="short_description" type="text" placeholder="A short description of your experiment"
                     required={true}
                     onChange={this.handleChange("short_description")}/>
            </label>
            <label>
              <p>Long Description</p>
              <textarea name="long_description"
                        placeholder="Long description of your experiment. Supports GitHub-flavored markdown (Optional)"
                        onChange={(event) => this.setState({
                          artifact: {
                            ...this.state.artifact,
                            long_description: event.target.value
                          }
                        })}/>
            </label>
            <label>
              <p>Visibility</p>
              <select name="visibility" title="Allow other users to view your artifact"
                      defaultValue={ArtifactVisibility.PRIVATE}
                      onChange={(event) => this.setState({
                        artifact: {
                          ...this.state.artifact,
                          visibility: event.target.value as ArtifactVisibility
                        }
                      })}>
                <option value={ArtifactVisibility.PUBLIC}>private</option>
                <option value={ArtifactVisibility.PRIVATE}>public</option>
              </select>
            </label>
            <h3>Reproducibility</h3>
            <label title="Allow other users to request time to reproduce your experiment">
              <p>Enable reproducibility requests?</p>
              <input name="repro_enable_requests" type="checkbox"
                     checked={this.state.artifact.reproducibility.enable_requests}
                     onChange={this.handleReproChange("enable_requests")}/>
            </label>
            <label className="repro-Input"
                   title="The number of hours a user will have to reproduce your experiment"
                   style={this.state.artifact.reproducibility.enable_requests ? ArtifactEditForm.block : ArtifactEditForm.hidden}>
              <p>Access Hours</p>
              <input name="repro_access_hours" type="number" defaultValue={3}
                     onChange={this.handleReproChange("access_hours")}/>
            </label>
            <label>
              <h3>Authors</h3>
              <ArtifactDynamicLengthList
                  artifactUpdater={items => this.setState({artifact: {...this.state.artifact, authors: items}})}
                  newComponentGenerator={(item, updater, getter) =>
                      <ArtifactAuthorComponent
                          initialAuthor={item} onFieldChange={updater} getAuthor={getter}
                      />
                  }
                  newObjectGenerator={() => new ArtifactAuthor()}
                  initialList={[...this.state.artifact.authors]}
              />
            </label>
            <label>
              <h3>Linked Projects</h3>
              <ArtifactDynamicLengthList
                  artifactUpdater={items => this.setState({artifact: {...this.state.artifact, linked_projects: items}})}
                  newComponentGenerator={(item, updater, getter) =>
                      <ArtifactLinkedProjectComponent
                          initialProject={item} onFieldChange={updater} getProject={getter}
                      />
                  }
                  newObjectGenerator={() => new ArtifactProject()}
                  initialList={[...this.state.artifact.linked_projects]}
              />
            </label>
            <label>
              <h3>Links</h3>
              <ArtifactDynamicLengthList
                  artifactUpdater={items => {
                    const currentVersion = this.state.artifact.currentVersion;
                    this.setState({
                      artifact: {
                        ...this.state.artifact, currentVersion: {...currentVersion, links: items}
                      }
                    })
                  }}
                  newComponentGenerator={(item, updater, getter) =>
                      <ArtifactLinkComponent
                          initialLink={item}
                          onFieldChange={updater}
                          getLink={getter}
                      />
                  }
                  newObjectGenerator={() => new ArtifactLink()}
                  initialList={[...this.state.artifact.currentVersion.links]}/>
            </label>
          </fieldset>
          <button name="artifact-Form-Submit" type="submit">
            {this.state.artifact.id ? "Save Changes" : "Create Artifact"}
          </button>
        </form>
    )
  }
}

export class ArtifactSharingComponent extends React.Component<ArtifactSharingComponent.IProps, ArtifactSharingComponent.IState> {
  constructor(props: ArtifactSharingComponent.IProps) {
    super(props);

    let startState: WidgetState;
    switch (this.props.workflow) {
      case 'upload':
        startState = WidgetState.CONFIRM_FORM;
        break;
      case 'edit':
        startState = WidgetState.ARTIFACT_FORM;
        break;
      default:
        break;
    }

    this.state = {
      artifact: this.props.initialArtifact,
      currentState: startState,
      errorMessage: null
    };

    this.onSubmit = this.onSubmit.bind(this);
    this.onMessage = this.onMessage.bind(this);
  }

  componentDidMount(): void {
    window.addEventListener('message', this.onMessage);
  }

  async onMessage(event: MessageEvent): Promise<void> {
    if (!this.props.urlFactory.isExternalUrl(event.origin)) {
      return;
    }

    event.preventDefault();
    const payload = event.data as ArtifactSharingComponent.IFormResultPayload;
    if (payload.message !== 'save_result') {
      console.log(`Ignoring postMessage type "${payload.message}"`);
      return;
    }

    if (!payload.body) {
      throw new Error('Invalid post message payload');
    }

    if (payload.body.status === 'success') {
      const newState: ArtifactSharingComponent.IState = {
        currentState: WidgetState.SUCCESS
      };

      if (this.props.workflow === 'upload') {
        // There are two cases we care about: a user is creating their own
        // artifact from an existing fork, or they are creating a new one
        // altogether.
        const isNewOwnedArtifact =
            !this.state.artifact.id || this.state.artifact.ownership !== "own";

        if (isNewOwnedArtifact) {
          const artifact = {...this.state.artifact}
          try {
            await this.props.artifactRegistry.commitArtifact(artifact);
            newState.artifact = artifact;
          } catch (err) {
            newState.errorMessage = `Failed to sync state of artifact: ${err.message}`;
          }
        }
      }

      this.setState(newState);
    } else {
      this.props.onCancel();
    }
  }

  async onSubmit(event: React.FormEvent): Promise<void> {
    event.preventDefault();
    const previousState = this.state.currentState;
    alert(JSON.stringify(this.state.artifact));
    this.setState({currentState: WidgetState.WAITING});
    if (previousState === WidgetState.CONFIRM_FORM) {
      // After the confirm form, we upload the state of the experiment
      try {
        const contents = await this.props.artifactRegistry.createContents(
            this.state.artifact.path
        );
        console.trace();
        this.setState({
          currentState: WidgetState.ARTIFACT_FORM,
          artifact: {
            ...this.state.artifact,
            currentVersion: {...this.state.artifact.currentVersion, contents: contents}
          }
        });
      } catch (e) {
        this.setState({
          currentState: WidgetState.CONFIRM_FORM,
          errorMessage: `Failed to package artifact: ${e.message}`
        });
      }
    } else if (previousState === WidgetState.ARTIFACT_FORM) {
      // After the artifact form is submitted, we upload the metadata
      let artifact: Artifact;
      try {
        if (this.state.artifact.id) {
          artifact = await this.props.artifactRegistry.newArtifactVersion(this.state.artifact);
        } else {
          artifact = await this.props.artifactRegistry.createArtifact(this.state.artifact);
        }
        this.setState({currentState: WidgetState.SUCCESS, artifact: artifact})
      } catch (e) {
        this.setState({
          currentState: WidgetState.ARTIFACT_FORM,
          errorMessage: `Failed to package artifact: ${e.message}`
        });
      }
    }
  }

  render(): JSX.Element {
    const hidden = {display: 'none'};
    const block = {display: 'block'};
    const visibilities = this._allStates.reduce((memo, state: WidgetState) => {
      memo[state] = this.state.currentState === state ? block : hidden;
      return memo;
    }, {} as { [key in WidgetState]: { display: string } });

    let formText: React.ElementRef<any>;
    let successText: React.ElementRef<any>;

    // Check if we started from an already-published artifact.
    if (this.props.initialArtifact.id) {
      formText = <NewArtifactVersionText urlFactory={this.props.urlFactory}/>;
      successText = (
          <NewArtifactVersionSuccessText
              urlFactory={this.props.urlFactory}
              artifact={this.state.artifact}
          />
      );
    } else {
      formText = <NewArtifactText urlFactory={this.props.urlFactory}/>;
      successText = (
          <NewArtifactSuccessText
              urlFactory={this.props.urlFactory}
              artifact={this.state.artifact}
          />
      );
    }

    return (
        <div className="chi-Expand">
          <div
              className="chi-ArtifactSharing-Form"
              style={visibilities[WidgetState.CONFIRM_FORM]}
          >
            <form onSubmit={this.onSubmit}>
              {this.state.errorMessage && (
                  <div className="chi-ArtifactSharing-ErrorMessage">
                    {this.state.errorMessage}
                  </div>
              )}
              {formText}
              <div className="chi-ArtifactSharing-FormActions">
                <button className="jp-mod-styled jp-mod-accept" type="submit">
                  Upload: <code>{this.state.artifact.path}/</code>
                </button>
              </div>
            </form>
          </div>
          <div
              className="chi-ArtifactSharing-Form"
              style={visibilities[WidgetState.ARTIFACT_FORM]}
          >
            {this.state.currentState === WidgetState.ARTIFACT_FORM && (
                <ArtifactEditForm initialArtifact={this.state.artifact}
                                  formVisibility={visibilities[WidgetState.ARTIFACT_FORM]}
                                  sharingComponent={this}/>
            )
            }
          </div>
          <div
              className="chi-ArtifactSharing-Form"
              style={visibilities[WidgetState.WAITING]}
          >
            <div className="jp-Spinner">
              <div className="jp-SpinnerContent"></div>
              <div className="chi-ArtifactSharing-LoadingMessage">
                Please wait while your files are uploaded&hellip;
              </div>
            </div>
          </div>
          <div
              className="chi-ArtifactSharing-Form"
              style={visibilities[WidgetState.SUCCESS]}
          >
            {this.state.errorMessage && (
                <div className="chi-ArtifactSharing-ErrorMessage">
                  {this.state.errorMessage}
                </div>
            )}
            {successText}
          </div>
        </div>
    );
  }

  private _allStates = Object.values(WidgetState);
}

export class ArtifactSharingWidget extends ReactWidget {
  constructor(
      artifact: Artifact,
      workflow: Workflow,
      urlFactory: IArtifactSharingURL,
      artifactRegistry: IArtifactRegistry
  ) {
    super();
    this.id = 'artifact-sharing-Widget';
    this._artifact = artifact;
    this._workflow = workflow;
    this._urlFactory = urlFactory;
    this._artifactRegistry = artifactRegistry;
  }

  render(): JSX.Element {
    return (
        <ArtifactSharingComponent
            initialArtifact={this._artifact}
            workflow={this._workflow}
            urlFactory={this._urlFactory}
            artifactRegistry={this._artifactRegistry}
            // Disposing of a widget added to a MainContentArea will cause the
            // content area to also dispose of itself (close itself.)
            onCancel={this.dispose.bind(this)}
        />
    );
  }

  private _artifact: Artifact;
  private _workflow: Workflow;
  private _urlFactory: IArtifactSharingURL;
  private _artifactRegistry: IArtifactRegistry;
}
