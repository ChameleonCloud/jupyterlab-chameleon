import {ReactWidget} from '@jupyterlab/apputils';
import * as React from 'react';
import {ChangeEvent} from 'react';
import {
  Artifact,
  ArtifactAuthor,
  ArtifactLink,
  ArtifactProject,
  ArtifactVisibility,
  IArtifactRegistry,
  IArtifactSharingURL,
  Workflow
} from './tokens';

enum WidgetState {
  CONFIRM_FORM = 'confirm-form',
  ARTIFACT_FORM = 'artifact-form',
  WAITING = 'waiting',
  SUCCESS = 'success'
}

namespace ArtifactSharingComponent {
  export interface IProps {
    initialArtifact: Artifact;
    workflow: Workflow;
    urlFactory: IArtifactSharingURL;
    artifactRegistry: IArtifactRegistry;
    onCancel(): void;
  }

  export interface IState {
    currentState: WidgetState;
    errorMessage?: string;
    artifact?: Artifact;
  }

  export interface IFormResultPayload {
    message: 'save_result' | any;
    body: {
      status: 'success' | 'cancel';
      id?: string;
    };
  }
}

namespace ArtifactText {
  export interface IProps {
    urlFactory: IArtifactSharingURL;
    artifact?: Artifact;
  }
}

namespace ArtifactForm {

  export interface IProps {
    artifact: Artifact;
    formVisibility: object;
    onChange: (fieldName: string) => (event: ChangeEvent<HTMLInputElement | HTMLTextAreaElement | HTMLSelectElement>) => void;
    onListChange: <T>(fieldName: string) => (list: Array<T>) => void
    onSubmit: (event: React.FormEvent) => Promise<void>;
    error: string;
  }

  export interface ListProps<E extends JSX.Element, T> {
    // When a new item is added to the list, it will be generated by this function
    newComponentGenerator: (item: T, updater: (field: string) => (event: ChangeEvent<HTMLInputElement>) => void, disabled: boolean) => E;
    newObjectGenerator: () => T;
    list: Array<T>;
    artifactUpdater: (items: Array<T>) => void;
    disabled: boolean;
  }

  export interface AuthorProps {
    author: ArtifactAuthor;
    onFieldChange: (field: string) => (event: ChangeEvent<HTMLInputElement>) => void;
    disabled: boolean;
  }

  export interface ProjectProps {
    project: ArtifactProject;
    onFieldChange: (field: string) => (event: ChangeEvent<HTMLInputElement>) => void;
    disabled: boolean;
  }

  export interface LinkProps {
    link: ArtifactLink;
    onFieldChange: (field: string) => (event: ChangeEvent<HTMLInputElement>) => void;
  }
}

class NewArtifactText extends React.Component<ArtifactText.IProps> {
  render() {
    return (
        <div>
          <h2>Package new artifact</h2>
          <p>
            Packaging your work as an <i>artifact</i> makes it easier to share
            your Notebook(s) and related files with others. A packaged experiment:
          </p>
          <ul>
            <li>can by &ldquo;replayed&rdquo; by any Chameleon user</li>
            <li>
              is displayed in{' '}
              <a
                  href={this.props.urlFactory.indexUrl()}
                  rel="noreferrer"
                  target="_blank"
              >
                Chameleon Trovi
              </a>{' '}
              (artifact sharing system)
            </li>
            <li>
              is initially private to you, but can be shared, either with specific
              projects, or all users
            </li>
            <li>supports versioning, if you ever want to make changes</li>
          </ul>
          <p>
            To learn more about Trovi, and artifact packaging, please refer to the{' '}
            <a
                href="https://chameleoncloud.readthedocs.io"
                rel="noreferrer"
                target="_blank"
            >
              Chameleon documentation
            </a>
            .
          </p>
        </div>
    );
  }
}

class NewArtifactSuccessText extends React.Component<ArtifactText.IProps> {
  render() {
    return (
      <div>
        <h2>Your artifact was successfully packaged.</h2>
        {this.props.artifact && (
          <p>
            You can view your artifact at any time on{' '}
            <a
              href={this.props.urlFactory.detailUrl(this.props.artifact.id)}
              target="_blank"
              rel="noreferrer"
            >
              Trovi
            </a>
            .
          </p>
        )}
        <p>You may now close this window.</p>
      </div>
    );
  }
}

class NewArtifactVersionText extends React.Component<ArtifactText.IProps> {
  render() {
    return (
      <div>
        <h2>Create new artifact version</h2>
        <p>
          When you create a new version of an existing package, your
          package&rsquo;s files are re-uploaded and then saved as a new
          launchable artifact. Creating a new version makes sense if you make
          adjustments to your code or Notebooks, perhaps fixing a bug or adding
          additional capabilities or functionality.
        </p>
        <p>
          If you want to start a new packaged artifact, you can do so by moving
          the files you want included in the package to their own directory,
          outside of any already-published package directories.
        </p>
        <p>
          All package versions are displayed in Trovi along with your existing
          artifact title, description, and other metadata. You can optionally
          edit this metadata before saving your new version.
        </p>
      </div>
    );
  }
}

class NewArtifactVersionSuccessText extends React.Component<ArtifactText.IProps> {
  render() {
    return (
      <div>
        <h2>A new version of your artifact was created.</h2>
        {this.props.artifact && (
          <p>
            You can view your artifact at any time on{' '}
            <a
              href={this.props.urlFactory.detailUrl(this.props.artifact.id)}
              target="_blank"
              rel="noreferrer"
            >
              Trovi
            </a>
            .
          </p>
        )}
        <p>You may now close this window.</p>
      </div>
    );
  }
}

class ArtifactDynamicLengthList<E extends JSX.Element, T> extends React.Component<ArtifactForm.ListProps<E, T>> {
  static defaultProps: { disabled: false };

  constructor(props: ArtifactForm.ListProps<E, T>) {
    super(props);

    const initialList = this.props.list;
    this.state = {list: initialList.length > 0 ? initialList : [this.props.newObjectGenerator()]};
  }

  addItem(index: number) {
    return (_: any) => {
      let copy = [...this.props.list];
      copy.splice(index + 1, 0, this.props.newObjectGenerator());
      return this.props.artifactUpdater(copy);
    };
  }

  removeItem(index: number) {
    return (_: any) => {
      let copy = [...this.props.list];
      copy.splice(index, 1);
      return this.props.artifactUpdater(copy);
    }
  }

  updateItem(index: number) {
    return (field: string) => {
      return (event: ChangeEvent<HTMLInputElement>) => {
        const value = event.target.value;
        let newList = [...this.props.list]
        newList[index] = {...newList[index], [field]: value}
        return this.props.artifactUpdater(newList);
      };
    };
  }

  getListForComponents(): Array<T> {
    if (this.props.list.length < 1) {
      return [this.props.newObjectGenerator()];
    } else {
      return this.props.list;
    }
  }

  render() {
    return (
        <ul>
          {this.getListForComponents().map((item, index) => (
                  <div key={index}>
                    <li>{this.props.newComponentGenerator(item, this.updateItem(index), this.props.disabled)}</li>
                    <button type="button" onClick={this.addItem(index)} disabled={this.props.disabled}>+</button>
                    <button type="button" onClick={this.removeItem(index)} disabled={this.props.disabled}>-</button>
                  </div>
              )
          )}
        </ul>
    )
  }
}

class ArtifactAuthorComponent extends React.Component<ArtifactForm.AuthorProps> {
  constructor(props: ArtifactForm.AuthorProps) {
    super(props);
  }

  hasAnyInput(): boolean {
    const author = this.props.author;
    return author.email !== "" || author.affiliation !== "" || author.full_name !== "";
  }

  render(): JSX.Element {
    const author = this.props.author;
    return (
        <div className="authorInput">
          <label>
            <p>Full Name</p>
            <input
                name="author_full_name"
                type="text"
                placeholder="The author's full name"
                required={this.hasAnyInput()}
                value={author.full_name}
                onChange={this.props.onFieldChange("full_name")}
                disabled={this.props.disabled}
            />
          </label>
          <label>
            <p>E-Mail Address</p>
            <input
                name="author_email"
                type="email"
                placeholder="The author's e-mail address"
                required={this.hasAnyInput()}
                value={author.email}
                onChange={this.props.onFieldChange("email")}
                disabled={this.props.disabled}
            />
          </label>
          <label>
            <p>Affiliation</p>
            <input
                name="author_affiliation"
                type="text"
                placeholder="The organization or group with which the author is affiliated"
                value={author.affiliation}
                onChange={this.props.onFieldChange("affiliation")}
                disabled={this.props.disabled}
            />
          </label>
        </div>
    )
  }
}

class ArtifactLinkedProjectComponent extends React.Component<ArtifactForm.ProjectProps> {
  constructor(props: ArtifactForm.ProjectProps) {
    super(props);
  }

  render() {
    const project = this.props.project;
    return (
        <div className="linkedProjectInput">
          <label>
            <p>URN</p>
            {/* We just let users input a raw URN. We should probably have a dropdown of their projects... */}
            <input
                name="linked-Project-Urn-Input"
                type="text"
                placeholder="A URN describing a project"
                onChange={this.props.onFieldChange("urn")}
                value={project.urn}
                disabled={this.props.disabled}
            />
          </label>
        </div>
    )
  }
}

class ArtifactLinkComponent extends React.Component<ArtifactForm.LinkProps> {
  constructor(props: ArtifactForm.LinkProps) {
    super(props);
  }

  isAnythingSet(): boolean {
    const link = this.props.link;
    return (link.urn !== null &&
            link.urn !== undefined &&
            link.urn !== "") ||
        (link.label !== null &&
            link.label !== undefined &&
            link.label !== "");
  }

  render() {
    const link = this.props.link;
    return (
        <div className="linkInput">
          <label>
            <p>URN</p>
            {/* This should be reworked, rather than just allowing the user to set arbitrary URNs */}
            <input name="link_urn" type="text" placeholder="A URN string describing the link"
                   required={this.isAnythingSet()}
                   value={link.urn}
                   onChange={this.props.onFieldChange("urn")}/>
          </label>
          <label>
            <p>Label</p>
            <input name="link_label" type="text" placeholder="A label which describes the link's content"
                   required={this.isAnythingSet()}
                   value={link.label}
                   onChange={this.props.onFieldChange("label")}/>
          </label>
        </div>
    )
  }
}

class ArtifactEditForm extends React.Component<ArtifactForm.IProps> {
  static readonly hidden = {display: 'none'};
  static readonly block = {display: 'block'};

  isCreateForm(): boolean {
    return this.props.artifact.id === null || this.props.artifact.id === undefined;
  }

  visibleOnlyOnNewVersion(): object {
    return this.props.artifact.id ? ArtifactEditForm.block : ArtifactEditForm.hidden
  }

  render(): JSX.Element {
    return (
        <form onSubmit={this.props.onSubmit} style={this.props.formVisibility}>
          {this.props.error && (
              <div className="chi-ArtifactSharing-ErrorMessage">
                {this.props.error}
              </div>
          )}
          <fieldset id="artifactFormInputs">
            <label style={this.visibleOnlyOnNewVersion()}>
              <p>ID</p>
              <input
                  name="id"
                  type="text"
                  value={this.props.artifact.id}
                  alt="The UUID used to reference this artifact"
                  disabled
              />
            </label>
            <label>
              <p className="chi-ArtifactSharing-Form-Required">Title</p>
              <input
                  name="title"
                  type="text"
                  placeholder="The title of your experiment"
                  required={true}
                  onChange={this.props.onChange("title")}
                  disabled={!this.isCreateForm()}
              />
            </label>
            <label>
              <p className="chi-ArtifactSharing-Form-Required">Short Description</p>
              <input
                  name="short_description"
                  type="text"
                  placeholder="A short description of your experiment"
                  required={true}
                  onChange={this.props.onChange("short_description")}
                  disabled={!this.isCreateForm()}
              />
            </label>
            <label>
              <p>Long Description</p>
              <textarea
                  name="long_description"
                  placeholder="Long description of your experiment. Supports GitHub-flavored markdown (Optional)"
                  onChange={this.props.onChange("long_description")}
                  disabled={!this.isCreateForm()}
              />
            </label>
            <label>
              <p>Visibility</p>
              <select
                  name="visibility"
                  title="Allow other users to view your artifact"
                  defaultValue={ArtifactVisibility.PRIVATE}
                  onChange={this.props.onChange("visibility")}
                  disabled={!this.isCreateForm()}
              >
                <option value={ArtifactVisibility.PRIVATE}>private</option>
                <option value={ArtifactVisibility.PUBLIC}>public</option>
              </select>
            </label>
            <h3>Reproducibility</h3>
            <label title="Allow other users to request time to reproduce your experiment">
              <p>Enable reproducibility requests?</p>
              <input
                  name="repro-Enable-Requests"
                  type="checkbox"
                  checked={this.props.artifact.reproducibility.enable_requests}
                  onChange={this.props.onChange("enable_requests")}
                  disabled={!this.isCreateForm()}
              />
            </label>
            <label
                className="repro-Input"
                title="The number of hours a user will have to reproduce your experiment"
                style={this.props.artifact.reproducibility.enable_requests ? ArtifactEditForm.block : ArtifactEditForm.hidden}
            >
              <p>Access Hours</p>
              <input
                  name="repro_access_hours"
                  type="number"
                  defaultValue={3}
                  onChange={this.props.onChange("access_hours")}
                  disabled={!this.isCreateForm()}
              />
            </label>
            <label>
              <h3>Authors</h3>
              <ArtifactDynamicLengthList
                  artifactUpdater={this.props.onListChange("authors")}
                  newComponentGenerator={(item, updater, disabled) =>
                      <ArtifactAuthorComponent author={item} onFieldChange={updater} disabled={disabled}/>
                  }
                  newObjectGenerator={() => ({full_name: "", email: "", affiliation: ""})}
                  list={[...this.props.artifact.authors]}
                  disabled={!this.isCreateForm()}
              />
            </label>
            <label>
              <h3>Linked Projects</h3>
              <ArtifactDynamicLengthList
                  artifactUpdater={this.props.onListChange("linked_projects")}
                  newComponentGenerator={(item, updater, disabled) =>
                      <ArtifactLinkedProjectComponent
                          project={item} onFieldChange={updater} disabled={disabled}
                      />
                  }
                  newObjectGenerator={() => ({urn: ""})}
                  list={[...this.props.artifact.linked_projects]}
              />
            </label>
            <label>
              <h3>Links</h3>
              <ArtifactDynamicLengthList
                  artifactUpdater={this.props.onListChange("newLinks")}
                  newComponentGenerator={(item, updater) =>
                      <ArtifactLinkComponent link={item} onFieldChange={updater}/>
                  }
                  newObjectGenerator={() => ({urn: "", label: ""})}
                  list={[...this.props.artifact.newLinks]}/>
            </label>
          </fieldset>
          <button name="artifact-Form-Submit" type="submit">
            {this.props.artifact.id ? "Save Changes" : "Create Artifact"}
          </button>
        </form>
    )
  }
}

export class ArtifactSharingComponent extends React.Component<ArtifactSharingComponent.IProps, ArtifactSharingComponent.IState> {
  constructor(props: ArtifactSharingComponent.IProps) {
    super(props);

    let startState: WidgetState;
    switch (this.props.workflow) {
      case 'upload':
        startState = WidgetState.CONFIRM_FORM;
        break;
      case 'edit':
        startState = WidgetState.ARTIFACT_FORM;
        break;
      default:
        break;
    }

    this.state = {
      artifact: this.props.initialArtifact,
      currentState: startState,
      errorMessage: null
    };

    this.onSubmit = this.onSubmit.bind(this);
    this.onMessage = this.onMessage.bind(this);
    this.handleChange = this.handleChange.bind(this);
    this.handleListChange = this.handleListChange.bind(this);
  }

  handleChange(fieldName: string) {
    return (event: ChangeEvent<HTMLInputElement | HTMLTextAreaElement | HTMLSelectElement>) => {
      switch (fieldName) {
        case "visibility":
          this.setState({
            artifact: {
              ...this.state.artifact,
              visibility: event.target.value as ArtifactVisibility
            }
          });
          return;
        case "enable_requests":
          this.setState({
            artifact: {
              ...this.state.artifact,
              reproducibility: {
                ...this.state.artifact.reproducibility,
                enable_requests: (event.target as HTMLInputElement).checked
              }
            }
          });
          return;
        case "access_hours":
          this.setState({
            artifact: {
              ...this.state.artifact,
              reproducibility: {
                ...this.state.artifact.reproducibility,
                access_hours: event.target.value as unknown as number
              }
            }
          });
          return;
        default:
          this.setState({artifact: {...this.state.artifact, [fieldName]: event.target.value}});
          return;
      }
    };
  }

  handleListChange<T>(fieldName: string) {
    return (list: Array<T>) => {
      this.setState({artifact: {...this.state.artifact, [fieldName]: list}});
    }
  }

  componentDidMount(): void {
    window.addEventListener('message', this.onMessage);
  }

  async onMessage(event: MessageEvent): Promise<void> {
    if (!this.props.urlFactory.isExternalUrl(event.origin)) {
      return;
    }

    event.preventDefault();
    const payload = event.data as ArtifactSharingComponent.IFormResultPayload;
    if (payload.message !== 'save_result') {
      console.log(`Ignoring postMessage type "${payload.message}"`);
      return;
    }

    if (!payload.body) {
      throw new Error('Invalid post message payload');
    }

    if (payload.body.status === 'success') {
      const newState: ArtifactSharingComponent.IState = {
        currentState: WidgetState.SUCCESS
      };

      if (this.props.workflow === 'upload') {
        // There are two cases we care about: a user is creating their own
        // artifact from an existing fork, or they are creating a new one
        // altogether.
        const isNewOwnedArtifact =
            !this.state.artifact.id || this.state.artifact.ownership !== "own";

        if (isNewOwnedArtifact) {
          const artifact = {...this.state.artifact}
          try {
            await this.props.artifactRegistry.commitArtifact(artifact);
            newState.artifact = artifact;
          } catch (err) {
            newState.errorMessage = `Failed to sync state of artifact: ${err.message}`;
          }
        }
      }

      this.setState(newState);
    } else {
      this.props.onCancel();
    }
  }

  async onSubmit(event: React.FormEvent): Promise<void> {
    event.preventDefault();
    const previousState = this.state.currentState;
    this.setState({currentState: WidgetState.WAITING});
    if (previousState === WidgetState.CONFIRM_FORM) {
      // After the confirm form, we upload the state of the experiment
      try {
        const contents = await this.props.artifactRegistry.createContents(
            this.state.artifact.path
        );
        this.setState({
          currentState: WidgetState.ARTIFACT_FORM,
          artifact: {
            ...this.state.artifact,
            newContents: contents
          }
        });
      } catch (e) {
        this.setState({
          currentState: WidgetState.CONFIRM_FORM,
          errorMessage: `Failed to package artifact: ${e.message}`
        });
      }
    } else if (previousState === WidgetState.ARTIFACT_FORM) {
      // After the artifact form is submitted, we upload the metadata
      let artifact: Artifact;
      try {
        if (this.state.artifact.id) {
          const version = await this.props.artifactRegistry.newArtifactVersion(this.state.artifact);
          artifact = {...this.state.artifact, versions: [...this.state.artifact.versions, version]}
        } else {
          artifact = await this.props.artifactRegistry.createArtifact(this.state.artifact);
        }
        this.setState({currentState: WidgetState.SUCCESS, artifact: artifact, errorMessage: null})
      } catch (e) {
        this.setState({
          currentState: WidgetState.ARTIFACT_FORM,
          errorMessage: `Failed to package artifact: ${e.message}`
        });
      }
    }
  }

  render(): JSX.Element {
    const hidden = {display: 'none'};
    const block = {display: 'block'};
    const visibilities = this._allStates.reduce((memo, state: WidgetState) => {
      memo[state] = this.state.currentState === state ? block : hidden;
      return memo;
    }, {} as { [key in WidgetState]: { display: string } });

    let formText: React.ElementRef<any>;
    let successText: React.ElementRef<any>;

    // Check if we started from an already-published artifact.
    if (this.props.initialArtifact.id) {
      formText = <NewArtifactVersionText urlFactory={this.props.urlFactory}/>;
      successText = (
          <NewArtifactVersionSuccessText
              urlFactory={this.props.urlFactory}
              artifact={this.state.artifact}
          />
      );
    } else {
      formText = <NewArtifactText urlFactory={this.props.urlFactory}/>;
      successText = (
          <NewArtifactSuccessText
              urlFactory={this.props.urlFactory}
              artifact={this.state.artifact}
          />
      );
    }

    return (
        <div className="chi-Expand">
          <div
              className="chi-ArtifactSharing-Form"
              style={visibilities[WidgetState.CONFIRM_FORM]}
          >
            <form onSubmit={this.onSubmit}>
              {this.state.errorMessage && (
                  <div className="chi-ArtifactSharing-ErrorMessage">
                    {this.state.errorMessage}
                  </div>
              )}
              {formText}
              <div className="chi-ArtifactSharing-FormActions">
                <button className="jp-mod-styled jp-mod-accept" type="submit">
                  Upload: <code>{this.state.artifact.path}/</code>
                </button>
              </div>
            </form>
          </div>
          <div
              className="chi-ArtifactSharing-Form"
              style={visibilities[WidgetState.ARTIFACT_FORM]}
          >
            {this.state.currentState === WidgetState.ARTIFACT_FORM && (
                <ArtifactEditForm
                    artifact={this.state.artifact}
                    formVisibility={visibilities[WidgetState.ARTIFACT_FORM]}
                    onChange={this.handleChange}
                    onListChange={this.handleListChange}
                    onSubmit={this.onSubmit}
                    error={this.state.errorMessage}
                />
            )
            }
          </div>
          <div
              className="chi-ArtifactSharing-Form"
              style={visibilities[WidgetState.WAITING]}
          >
            <div className="jp-Spinner">
              <div className="jp-SpinnerContent"></div>
              <div className="chi-ArtifactSharing-LoadingMessage">
                Please wait while your files are uploaded&hellip;
              </div>
            </div>
          </div>
          <div
              className="chi-ArtifactSharing-Form"
              style={visibilities[WidgetState.SUCCESS]}
          >
            {this.state.errorMessage && (
                <div className="chi-ArtifactSharing-ErrorMessage">
                  {this.state.errorMessage}
                </div>
            )}
            {successText}
          </div>
        </div>
    );
  }

  private _allStates = Object.values(WidgetState);
}

export class ArtifactSharingWidget extends ReactWidget {
  constructor(
      artifact: Artifact,
      workflow: Workflow,
      urlFactory: IArtifactSharingURL,
      artifactRegistry: IArtifactRegistry
  ) {
    super();
    this.id = 'artifact-sharing-Widget';
    this._artifact = artifact;
    this._workflow = workflow;
    this._urlFactory = urlFactory;
    this._artifactRegistry = artifactRegistry;
  }

  render(): JSX.Element {
    return (
        <ArtifactSharingComponent
            initialArtifact={this._artifact}
            workflow={this._workflow}
            urlFactory={this._urlFactory}
            artifactRegistry={this._artifactRegistry}
            // Disposing of a widget added to a MainContentArea will cause the
            // content area to also dispose of itself (close itself.)
            onCancel={this.dispose.bind(this)}
        />
    );
  }

  private _artifact: Artifact;
  private _workflow: Workflow;
  private _urlFactory: IArtifactSharingURL;
  private _artifactRegistry: IArtifactRegistry;
}
